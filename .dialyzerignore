lib/prima_ex_logger.ex:11: Invalid type specification for function 'Elixir.PrimaExLogger':init/1. The success typing is ({'Elixir.PrimaExLogger',atom()}) -> {'ok',#{'encoder':=_, 'environment':=_, 'level':=_, 'metadata':=[any()], 'name':=atom(), 'type':=_}}
lib/prima_ex_logger.ex:20: Invalid type specification for function 'Elixir.PrimaExLogger':configure/2. The success typing is (atom(),[{atom(),_}]) -> #{'encoder':=_, 'environment':=_, 'level':=_, 'metadata':=[any()], 'name':=atom(), 'type':=_}
lib/prima_ex_logger.ex:73: Function forge_event/2 has no local return
lib/prima_ex_logger.ex:120: Function timestamp_to_iso/1 has no local return
lib/prima_ex_logger.ex:121: The call 'Elixir.NaiveDateTime':new(_year@1::any(),_month@1::any(),_day@1::any(),_hour@1::any(),_minute@1::any(),_second@1::any(),number()) will never return since it differs in the 7th argument from the success typing arguments: (integer(),integer(),integer(),integer(),integer(),integer(),{char(),0 | 1 | 2 | 3 | 4 | 5 | 6})
lib/prima_ex_logger.ex:109: The call 'Elixir.Timex':to_datetime(_ts@1::#{'__struct__':='Elixir.NaiveDateTime', 'calendar':=atom(), 'day':=integer(), 'hour':=integer(), 'microsecond':={char(),0 | 1 | 2 | 3 | 4 | 5 | 6}, 'minute':=integer(), 'month':=integer(), 'second':=integer(), 'year':=integer()},{'error',_} | #{'__struct__':='Elixir.Timex.AmbiguousTimezoneInfo' | 'Elixir.Timex.TimezoneInfo', 'abbreviation'=>binary(), 'after'=>#{'__struct__':='Elixir.Timex.TimezoneInfo', 'abbreviation':=binary(), 'from':='min' | {'friday' | 'monday' | 'saturday' | 'sunday' | 'thursday' | 'tuesday' | 'wednesday',{{non_neg_integer(),1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,1..255},{byte(),byte(),byte()}}}, 'full_name':=binary(), 'offset_std':=integer(), 'offset_utc':=integer(), 'until':='max' | {'friday' | 'monday' | 'saturday' | 'sunday' | 'thursday' | 'tuesday' | 'wednesday',{{non_neg_integer(),1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,1..255},{byte(),byte(),byte()}}}}, 'before'=>#{'__struct__':='Elixir.Timex.TimezoneInfo', 'abbreviation':=binary(), 'from':='min' | {'friday' | 'monday' | 'saturday' | 'sunday' | 'thursday' | 'tuesday' | 'wednesday',{{non_neg_integer(),1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,1..255},{byte(),byte(),byte()}}}, 'full_name':=binary(), 'offset_std':=integer(), 'offset_utc':=integer(), 'until':='max' | {'friday' | 'monday' | 'saturday' | 'sunday' | 'thursday' | 'tuesday' | 'wednesday',{{non_neg_integer(),1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12,1..255},{byte(),byte(),byte()}}}}, 'from'=>'min', 'full_name'=>binary(), 'offset_std'=>integer(), 'offset_utc'=>integer(), 'until'=>'max'}) breaks the contract ('Elixir.Timex.Types':valid_datetime(),'Elixir.Timex.Types':valid_timezone()) -> 'Elixir.DateTime':t() | 'Elixir.Timex.AmbiguousDateTime':t() | {'error',term()}
lib/prima_ex_logger.ex:141: Function log/2 will never be called
:0: Unknown function 'Elixir.Timex':'format!'/2
:0: Unknown function 'Elixir.Timex':to_datetime/2
:0: Unknown function 'Elixir.Timex.Timezone':local/0